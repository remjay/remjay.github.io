{"meta":{"title":"wjchen's | blog","subtitle":"","description":"wjchen's study notes","author":"wjchen","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-08-25T06:58:00.018Z","updated":"2021-08-25T06:58:00.018Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-08-25T07:36:33.545Z","updated":"2021-08-25T07:36:33.545Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2021-08-25T07:37:21.571Z","updated":"2021-08-25T07:37:21.571Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-08-25T07:39:50.779Z","updated":"2021-08-25T07:39:50.779Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2021-08-25T07:37:46.119Z","updated":"2021-08-25T07:37:46.119Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-25T07:38:13.755Z","updated":"2021-08-25T07:38:13.755Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"HTML学习笔记","slug":"HTML-study","date":"2021-11-10T02:44:50.054Z","updated":"2021-11-11T09:56:46.475Z","comments":true,"path":"2021/11/10/HTML-study/","link":"","permalink":"http://example.com/2021/11/10/HTML-study/","excerpt":"","text":"a 标签的五种使用方法 页面跳转(herf设置地址)1&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;&lt;/a&gt; 锚点链接(herf里面#号开头)1&lt;a href=&#x27;#zj&#x27;&gt;&lt;/a&gt; 下载文件(herf填入资源链接地址,并设置download属性设置下载文件名)1&lt;a href=&#x27;http://www.baidu.com/img/bd_logo1.png&#x27; download=&#x27;百度图片.png&#x27;&gt;&lt;/a&gt; 创建email链接 1&lt;a href=&#x27;mailto:1727482593@qq.com&#x27;&gt;发邮件&lt;/a&gt; 创建Tel链接1&lt;a href=&#x27;tel:12345678&#x27;&gt;拨打电话&lt;/a&gt;","categories":[],"tags":[],"author":"wjchen"},{"title":"JS学习笔记","slug":"JS-study","date":"2021-11-10T02:44:35.301Z","updated":"2021-11-19T03:19:32.908Z","comments":true,"path":"2021/11/10/JS-study/","link":"","permalink":"http://example.com/2021/11/10/JS-study/","excerpt":"","text":"判断数据类型的方法typeof 区分数据类型可以区分7种数据类型:string,number,boolean,object,undefined,function 和es6新增的symbol 注意 - typeof 返回格式是 string typeof(typeof(1)) - typeof 判断未定义的变量 返回 undefined - typeof 判断null 返回object - typeof(NaN) 返回number 2.instanceof 区分复杂数据类型能区分Array,Object和Function数据类型,但是String,Number,Boolean的简单类型数据不能判断instanceof 判断对象的原型链上是否存在构造函数的原型,且只能判断引用类型3.Object.prototype.toString.call() 精准判断数据类型,需进行封装后判断12345678910toString.call(()=&gt;&#123;&#125;) //[object Function]toString.call(&#123;&#125;) //[object Object]toString.call([]) //[object Array]toString.call(&#x27;&#x27;) //[object String]toString.call(11) //[object Number]toString.call(undefined) //[object undefined]toString.call(null) //[object null]toString.call(new Date) //[object Date]toString.call(Math) //[object Math]toString.call(window) //[object Window]","categories":[],"tags":[],"author":"wjchen"},{"title":"CSS学习笔记","slug":"CSS-study","date":"2021-11-10T02:44:15.714Z","updated":"2021-11-19T03:19:25.358Z","comments":true,"path":"2021/11/10/CSS-study/","link":"","permalink":"http://example.com/2021/11/10/CSS-study/","excerpt":"","text":"css单位 分为两种绝对长度与相对长度 绝对长度 px 像素 像素是相对于屏幕分辨率的,页面按照精确像素展示,不会因其他元素的变化而变化 in 英寸 在css领域中,直接被映射成像素 1in===96px cm 厘米 映射成像素 1cm=37.8px mm 毫米 映射成像素 1mm=3.78px pt 点 (1pt = 1/72 of 1in) pc 派卡 (1pc = 12 pt) 相对长度 rem 相对于根元素的字体大小（font-size） vw 相对于视口*宽度的 1% vh 相对于视口*高度的 1% em 相对于元素的字体大小（font-size）（2em 表示当前字体大小的 2 倍） % 相对于父元素","categories":[],"tags":[],"author":"wjchen"},{"title":"react全家桶使用注意","slug":"react全家桶使用注意","date":"2021-09-10T02:47:40.572Z","updated":"2021-09-10T02:55:21.527Z","comments":true,"path":"2021/09/10/react全家桶使用注意/","link":"","permalink":"http://example.com/2021/09/10/react%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","excerpt":"","text":"react脚手架有两种 通过create-react-app脚手架来构建react项目(1). 通过umijs脚手架来构建react项目","categories":[],"tags":[],"author":"wjchen"},{"title":"linux学习","slug":"linux学习","date":"2021-09-03T02:55:10.090Z","updated":"2021-09-03T03:11:04.406Z","comments":true,"path":"2021/09/03/linux学习/","link":"","permalink":"http://example.com/2021/09/03/linux%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"指令 cd .. 返回上级目录 pwd 显示工作路径 ls 查看目录中的文件 ls -a 显示隐藏文件 tree 显示文件和目录由根目录开始的树形结构 mkdir my 创建名称为my的目录 rm -f file 删除一个叫file的文件 rmdir dir1 删除一个叫dir1的目录 cp file1 file2 将file1复制file2","categories":[],"tags":[],"author":"wjchen"},{"title":"vue全家桶使用注意","slug":"vue全家桶使用注意","date":"2021-08-27T07:42:35.148Z","updated":"2021-08-30T03:00:00.787Z","comments":true,"path":"2021/08/27/vue全家桶使用注意/","link":"","permalink":"http://example.com/2021/08/27/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","excerpt":"","text":"$set的使用vue是数据驱动视图更新的,但在没给数据双向绑定和data层级的非简单数据类型,就会存在视图无法更新的情况,这就用到$set来实现视图的更新. 12this.$set(target,propertyName,value)// 来实现视图的更新 组件间通讯方式 父传子父子间组件通讯是 父组件通过v-bind给子组件绑定自定义属性,传通讯信息 子组件通过props接收父组件绑定的自定义属性值1234567891011121314151617181920// 父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;children :msg=&#x27;info&#x27;&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Children from &#x27;@/components/Children.vue&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; info: &#x27;你是我的儿子&#x27; &#125; &#125;, components: &#123; Children &#125;&#125;&lt;/script&gt; 123456789101112131415161718// 子组件&lt;template&gt; &lt;div&gt; &lt;p&gt;这是父组件的信息:&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;children&#x27;, props: &#123; msg: &#123; type: String, default: &#x27;&#x27;,//默认值 require: true//是否必填 &#125; &#125;&#125;&lt;/script&gt; 子传父子组件通讯父组件是通过自定义事件来收子组件的值 子组件通过$emit(组件自定义方法,要给父组件信息)1234567891011121314151617181920212223242526// 父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;这是儿子给我的信,信里写到: &#123;&#123;info&#125;&#125; &lt;/p&gt; &lt;children @info=&#x27;getLetter&#x27;&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Children from &#x27;@/components/Children.vue&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; info: &#x27;&#x27; &#125; &#125;, methods: &#123; getLetter(content) &#123; this.info = content &#125; &#125;, components: &#123; Children &#125;&#125;&lt;/script&gt; 12345678910111213141516// 子组件&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;giveFather&quot;&gt;点击发送信件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;children&#x27;, methods: &#123; giveFather() &#123; this.$emit(&#x27;info&#x27;, &#x27;父亲我想你了!&#x27;) &#125; &#125;,&#125;&lt;/script&gt; 兄弟组件通讯通过给全局创建一个new Vue()事件总线,并挂载在全局,$emit()和$on来实现兄弟组件的收发工作.12// main.jsVue.prototype.bus = new Vue() 12345678910111213141516// 组件1&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;giveBrother&quot;&gt;点击发送信件给我兄弟&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;children&#x27;, methods: &#123; giveBrother() &#123; this.bus.$emit(&#x27;getMsg&#x27;, &#x27;兄弟你真的很棒!&#x27;) &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021// 组件2&lt;template&gt; &lt;div&gt; &lt;p&gt;这是children给我的消息:&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;brother&#x27;, data() &#123; return &#123; info: &#x27;&#x27; &#125; &#125;, mounted() &#123; this.bus.$on(&#x27;getMsg&#x27;, value =&gt; &#123; this.info = value &#125;) &#125;,&#125;&lt;/script&gt; vuex 状态管理对于兄弟组件和更为复杂的组件通讯,我们可以使用vuex的状态管理,来实现全局组件的通讯,但依然会出现页面刷行后 状态管理全重置的问题,我们可以配合localStorage来将其保存,再次加载的时候,先去获取浏览器缓存的东西,做加载","categories":[],"tags":[],"author":"wjchen"},{"title":"element 组件使用注意","slug":"element组件使用注意","date":"2021-08-26T01:40:40.217Z","updated":"2021-08-26T02:51:05.590Z","comments":true,"path":"2021/08/26/element组件使用注意/","link":"","permalink":"http://example.com/2021/08/26/element%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","excerpt":"","text":"表格多选分页问题翻页时候,让表格多选记住上页的已选数据 首先我们需要给table组件上加上 row-key 属性绑定数据的唯一键 在多选组件上加上 reserve-selection 并绑定true 在table组件上加上 selection-change 方法 这样就实现了分页记住上页的勾选数据但这可仅仅不够,我们可能需要获取后台的数据,来实现回显 我们获取到后端数据库存的已选id,由于存在分页,所以当某页有所选id时就让其回显 先将所有的已选id存储在另一个变量中 表格行的回显,只能一行一行回显 通过table toggleRowSelection 方法来回显,这方法只能通过找到表格数据需要选中的行,将其设置成true就能将其回显 当回显过后,就将存储所有已选id的变量中删除对应元素","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-08-21T08:17:03.203Z","updated":"2021-08-21T08:17:03.203Z","comments":true,"path":"2021/08/21/hello-world/","link":"","permalink":"http://example.com/2021/08/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}