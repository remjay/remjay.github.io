{"meta":{"title":"wjchen's | blog","subtitle":"","description":"wjchen's study notes","author":"wjchen","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-08-25T06:58:00.018Z","updated":"2021-08-25T06:58:00.018Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-08-25T07:37:21.571Z","updated":"2021-08-25T07:37:21.571Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-25T07:36:33.545Z","updated":"2021-08-25T07:36:33.545Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2021-08-25T07:39:50.779Z","updated":"2021-08-25T07:39:50.779Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2021-08-25T07:37:46.119Z","updated":"2021-08-25T07:37:46.119Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-25T07:38:13.755Z","updated":"2021-08-25T07:38:13.755Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"node知识","slug":"node知识","date":"2023-03-16T02:19:27.828Z","updated":"2023-03-16T02:52:39.627Z","comments":true,"path":"2023/03/16/node知识/","link":"","permalink":"http://example.com/2023/03/16/node%E7%9F%A5%E8%AF%86/","excerpt":"","text":"node包管理 在前端高速发展中,node环境每年都有着更新,而且会导致各种依赖包的版本,需要不同的node环境来支撑,这样就会造成我们需要不同版本的node版本来支撑项目的开发,当前最热门的node包管理工具就是nvm 介绍 nvm 允许你快速的切换不同的node版本 安装nvm文件下载地址: nvm_window建议选择nvm-setup.exe安装版的,其他版本需要额外配置环境变量 notice: 安装文件放在c盘就无需进行本机的环境变量配置 若放在非c盘就需要自己配置一下环境变量 NVM_HOME 指向nvm NVM_SYMLINK 指向node 要配置淘宝镜像就需要在settings.txt 文件配置 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 验证是否成功 可以查询nvm版本. 经常使用指令 安装node版本 nvm install 展开所有本地安装的node版本 nvm ls 切换使用的node版本 nvm use 获取当前使用版本 nvm current 卸载node版本 nvm unistall","categories":[],"tags":[],"author":"wjchen"},{"title":"数据库知识","slug":"数据库知识","date":"2022-08-30T03:22:14.046Z","updated":"2022-08-30T07:49:56.795Z","comments":true,"path":"2022/08/30/数据库知识/","link":"","permalink":"http://example.com/2022/08/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/","excerpt":"","text":"数据库索引 数据库索引分为四类:稀疏索引,稠密索引,聚集索引,非聚集索引 稀疏索引只是一部分查找码的值有对应的索引记录 稠密索引每个索引键值都对应一个索引项相比稀疏索引:占用空间更小,且插入删除维护开销小 聚集索引(聚簇索引)聚集索引的顺序就是数据的物理存储顺序,对表的数据按索引键的顺序进行排序,然后重新存储到磁盘上.因为数据在物理存放时只能有一种排列方式,所以一个表只能有一个聚集索引 聚集索引可以重复指针索引-&gt;物理磁盘索引,且两者索引都相同 非聚集索引非聚集索引则与聚集索引相反,两者索引不相同 ORDER BY使用注意 order by 语句用于指定的列对结果集进行排序 order by 语句默认按照升序对记录进行排序 只能作为其他子句之后的最后一个子句出现,子查询语句中是不能使用order by语句的","categories":[],"tags":[],"author":"wjchen"},{"title":"网页认识","slug":"网页认识","date":"2022-05-12T02:05:58.240Z","updated":"2022-05-12T02:19:39.198Z","comments":true,"path":"2022/05/12/网页认识/","link":"","permalink":"http://example.com/2022/05/12/%E7%BD%91%E9%A1%B5%E8%AE%A4%E8%AF%86/","excerpt":"","text":"页面生成过程 html文件通过html解析器解析成 DOM树 css文件通过css解析器解析成CSSOM树 结合DOM和CSSOM树,生成一棵渲染树 生成布局,即将所有渲染树的所有节点进行平面合成 将布局绘制在屏幕上 前端搭建模式(单页面模式与多页面模式) 多页面模式(MPA)页面跳转会造成所有的html css js重新渲染 是多个完整的独立页面组成 适合用于高度追求支持搜索引擎的应用 单页面模式(SPA)一个初始页面和多个页面模块组成 html css js只在初始页面的时候渲染,更换页面无需重新加载","categories":[],"tags":[],"author":"wjchen"},{"title":"HTML学习笔记","slug":"HTML-study","date":"2021-11-10T02:44:50.054Z","updated":"2022-03-08T13:17:07.350Z","comments":true,"path":"2021/11/10/HTML-study/","link":"","permalink":"http://example.com/2021/11/10/HTML-study/","excerpt":"","text":"a 标签的五种使用方法 页面跳转(herf设置地址)1&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;&lt;/a&gt; 锚点链接(herf里面#号开头)1&lt;a href=&#x27;#zj&#x27;&gt;&lt;/a&gt; 下载文件(herf填入资源链接地址,并设置download属性设置下载文件名)1&lt;a href=&#x27;http://www.baidu.com/img/bd_logo1.png&#x27; download=&#x27;百度图片.png&#x27;&gt;&lt;/a&gt; 创建email链接 1&lt;a href=&#x27;mailto:1727482593@qq.com&#x27;&gt;发邮件&lt;/a&gt; 创建Tel链接1&lt;a href=&#x27;tel:12345678&#x27;&gt;拨打电话&lt;/a&gt; 浏览器渲染过程浏览器在渲染过程中,渲染引擎会触发回流和重绘 回流:当我们将dom元素的大小发生变化,浏览器要重新计算元素大小,这个过程称为 回流 重绘:当我们仅仅只是改变dom的颜色,此时浏览器不需要重新计算元素大小,这个过程就称为 重绘在两者对比中,显然回流会比重绘更损耗性能","categories":[],"tags":[],"author":"wjchen"},{"title":"JS学习笔记","slug":"JS-study","date":"2021-11-10T02:44:35.301Z","updated":"2022-05-27T07:22:20.676Z","comments":true,"path":"2021/11/10/JS-study/","link":"","permalink":"http://example.com/2021/11/10/JS-study/","excerpt":"","text":"javascript数据类型 基本数据类型:7种String Number Boolean undefined null Symbel Bigint - Symbel 表示独一无二的值，主要为了解决属性名冲突问题 - Bigint 是比Number类型的整数范围更大,不需要通过new来使用123456789//当数值超过最大安全值的时候,会无法判断超出值的比较let max=Number.MAX_SAFE_INTEGERlet maxOne=max+1let maxTwo=max+2console.log(maxOne===maxTwo) //truelet maxBig=Bigint(Number.MAX_SAFE_INTEGER)let maxBigOne=maxBig+1let maxBigTwo=maxBig+2console.log(maxBigOne===maxBigTwo) //false 引用数据类型:1种Object对象(包括普通Object、Function、Array、Date、RegExp、Math) instanceof 原理的实现 instanceof判断对象的原型链上是否存在构造函数的原型.仅能判断引用类型 instanceof 判断a是否是b的实例12345678910111213//判断A的原型链上是否有B的原型 返回true or falseA instanceof B//自定义实现instanceof功能function myInstanceof(example,constructor)&#123; if(typeof(example)!==&#x27;object&#x27;&amp;&amp;typeof(example)!==&#x27;function&#x27;||typeof(example)===&#x27;null&#x27;) return false let exampleProto=Object.getPrototypeOf(example) while(true)&#123; if(exampleProto===null) return false if(exampleProto===constructor.prototype) return true exampleProto=Object.getPrototypeOf(exampleProto) &#125;&#125; cookie, localStorage sessionStorage区别 cookie 可以设置cookie的过期时间,默认是浏览器关闭就失效 存储大小4k左右,cookie数据始终在同源的http请求中携带,即cookie在浏览器和服务器间来回传递。cookie数据还有路径(path)的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。 localStorage 除非被清除,否则永久保存 一般为5MB sessionStorage 仅当前会话窗口有效,关闭窗口或浏览器后被清除 一般5MB Promise实现 ES6的Promise实现需要遵循Promise/A+规范,通过阅读Promise/A+规范,你可以了解到有两条核心规则 Promise是一个状态控制器,且只能有三种状态:pending(等待态),fulfilled(执行态),rejected(拒绝态)状态是单项的,且流程不可逆 then()方法接收两个可选参数,分别触发对应改变时触发的回调.then()方法返回一个promise,then()方法可以多次调用一个promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class myPromise &#123; constructor (executor) &#123; this.status = PENDING //promise 状态 this._value = undefined // 储存then回调return的值 this._resolveList = [] //成功队列 resolve 触发 this._rejectList = [] //失败队列 reject 触发 let _resolve = (v) =&gt; &#123; let run = () =&gt; &#123; if (this._status !== PENDING) return // 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot; this._status = FULFILLED //修改状态 this._value = v while (this._resolveList.length) &#123; const callback = this._resolveList.shift() callback(v) &#125; &#125; setTimeout(run) &#125; let _reject = (v) =&gt; &#123; let run = () =&gt; &#123; if (this.status !== PENDING) return this._status = REJECTED this._value = v while (this._rejectList.length) &#123; const callback = this._rejectList.concat.shift() callback(v) &#125; &#125; setTimeout(run) &#125; executor(_resolve, _reject) &#125; // then()方法,在promise中是链式调用,且then()方法的回调拿到上个then()方法的返回值 then(resolveFn, rejectFn) &#123; typeof resolveFn !== &#x27;function&#x27; ? resolveFn = v =&gt; v : null typeof rejectFn !== &#x27;function&#x27; ? rejectFn = reason =&gt; &#123; throw new Error(reason instanceof Error ? reason.message : reason) &#125; : null return new myPromise((resolve, reject) =&gt; &#123; const fulfilledFn = v =&gt; &#123; try &#123; let x = resolveFn(v) x instanceof myPromise ? x.then(resolve, reject) : resolve(x) &#125; catch (error) &#123; reject(error) &#125; &#125; const rejectedFn = v =&gt; &#123; try &#123; let x = rejectFn(v) x instanceof myPromise ? x.then(resolve, reject) : reject(x) &#125; catch (error) &#123; reject(error) &#125; &#125; switch (this._status) &#123; case PENDING: //将其放在对应的队列 this._resolveList.push(fulfilledFn) this._rejectList.push(rejectedFn) break case FULFILLED: fulfilledFn(this._value) break case REJECTED: rejectedFn(this._value) break &#125; &#125;) &#125; // catch 方法捕获错误 catch(rejectFn) &#123; return this.then(undefined, rejectFn) &#125; //finally方法 finally(callback) &#123; return this.then( value =&gt; myPromise.resolve(callback()).then(() =&gt; value),//执行回调,并returnvalue传递给后面的then reason =&gt; myPromise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) //reject同理 ) &#125; //静态的resolve方法 static resolve(value) &#123; if (value instanceof myPromise) return value return new myPromise(resolve =&gt; resolve(value)) &#125; //静态的reject方法 static reject(reason) &#123; return new myPromise((resolve, reject) =&gt; reject(reason)) &#125; //静态的all方法 static all(promiseArr) &#123; let index = 0 let result = [] return new myPromise((resolve, reject) =&gt; &#123; promiseArr.forEach((p, i) =&gt; &#123; myPromise.resolve(p).then( val =&gt; &#123; index++ result[i] = val if (index === promiseArr.length) &#123; resolve(result) &#125; &#125;, err =&gt; &#123; reject(err) &#125; ) &#125;) &#125;) &#125; //静态的race方法 static race(promiseArr) &#123; return new myPromise((resolve, reject) =&gt; &#123; //同时执行Promise,如果有一个Promise的状态发生改变,就变更新myPromise的状态 for (let p of promiseArr) &#123; myPromise.resolve(p).then( value =&gt; &#123; resolve(value) &#125;, err =&gt; &#123; reject(err) &#125; ) &#125; &#125;) &#125;&#125; 通过对源码的解析,catch方法其实只是调用then方法,来实现reject错误信息的捕捉,在捕捉的同时会给resolve传递undifined值,使其promise状态凝固,由拒绝态变为执行态,让其不在进行错误的捕捉 new的原理是啥?通过new的方式创建对象与字面量创建的有啥区别? new: 创建一个新对象 这个新对象会执行[[原型]]连接 将构造函数的作用域赋值给新对象,即this指向新对象 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。123456789function myNew(fn) &#123; let target = &#123;&#125; target.__proto__ = fn.prototype //[[原型]]连接 let res = fn.call(target) if (typeof (res) === &#x27;object&#x27; || typeof (res) === &#x27;function&#x27;) &#123; return res &#125; return target&#125; 字面量创建和new创建的区别字面量创建对象,不会调用Object构造函数,简洁性好new Object() 方式创建对象本质上是方法调用,涉及到在proto链中遍历该方法，当找到该方法后,又会生产方法调用必须的堆栈信息,方法调用结束后，还要释放该堆栈，性能不如字面量的方式。 原型链 原型链主要解决的是继承问题. 每个对象拥有一个原型对象,通过proto指针指向其原型对象,并从中继承方法和属性,同时原型对象也可能拥有原型,这样一层一层,最终指向null(Object.proptotype.__proto__ 指向的是null)。这种关系被称为原型链,通过原型链一个对象可以拥有定义在其他对象中的属性和方法。 123456function Person() &#123; this.name = &#x27;cwj&#x27; this.age = 18&#125;let one = new Personconsole.log(one.__proto__===Person.prototype) //true 实现深拷贝 1234567891011121314function deepClone(obj) &#123; if (obj === null) return null //当数据类型为null时直接返回 if (obj instanceof RegExp) return new RegExp(obj) // 当数据为正则类型时 返回正则数据 if (obj instanceof Date) return new Date(obj) //当数据为日期时,返回日期数据 if (typeof obj !== &#x27;object&#x27;) &#123; return obj //数据不为复杂类型 直接返回 &#125; //当为复杂类型,就通过遍历再次递归调用 let o = new obj.constructor() for (let key in obj) &#123; o[key] = deepClone(obj[key]) &#125; return o&#125; EventLoop(事件循环) 由于js是单线程,每步都需要执行完才能进行下一步,所以为了防止堵塞,所以会将同步代码压入同步队列,异步代码压入异步队列.异步队列又分宏任务队列与微任务队列,由于宏任务执行时间较长,而且微任务的存在目的就是为了插队,所以微任务优先与宏任务.微任务代表Promise.then,MutationObserver,宏任务代表setTimeout,setInterval 执行顺序总结: 主线程的同步任务可以看做第一个宏任务,先执行主线程上的同步任务,异步任务放在异步队列中,宏任务放到下个宏任务队列,微任务放到微任务队列,当主线程同步任务执行完成之后,就按照先进先出的原则执行所有的微任务,微任务执行完后,执行下个宏任务队列 当宏任务执行完后,如果当前微任务队列有微任务就执行所有的微任务后,在进行下个宏任务 Promise不属于微任务,但他的.then()和.catch()才属于微任务 import与require的区别 区别1:模块加载的时间require:运行时加载import:编译时加载(效率更高)由于是编译时加载,所以import命令会提升到文件头部12a()import &#123;a&#125; from &#x27;./a&#x27; 这种情况就不会报错 区别2:模块本质区别require:模块就是对象,输入时必须寻找对象属性import:模块不是对象,而是通过export命令显式输出的代码,再通过import命令输入.由于ES6模块是在编译时加载,使得静态分析称为可能.就能进一步扩宽javascript语法,比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能123456//CommonJS模块const &#123;exists,readFile&#125; =require(&#x27;fs&#x27;)//等同于const fs=require(&#x27;fs&#x27;)const exists=fs.existsconst readFile=fs.readFile 上面实际上是加载了fs对象,fs模块所有方法实际上都加载了,在从对象上读取方法12//ES6模块import &#123;exists,readFile&#125; from &#x27;fs&#x27; import实际上是加载fs模块对应的两个方法,其他方法并不加载 区别3:严格模式CommonJS模块与ES6模块的区别: CommonJS模块默认采用非严格模式 ES6模块采用严格模式,不管你文件头部是否加入use strict CommonJS模块输出的是一个值的拷贝,ES6模块输出的是值的引用 (即当引入文件的参数发生变化es6引入会发生变化 而commonjs则不会变化) Map与Object的区别 Object与Map类似,它们都允许你按键存取一个值,删除键,检查一个键是否绑定值,不过在以下情况可能Map是最好的选择,Map的快速搜索和查找数据而生的 意外的键Map创建默认不含任何键,而Object可能在原型链上存在某个属性,这样创建新键存在属性名冲突我们可以用Object.create(null)来创建不含任何键的对象 键的类型Map键的值可以是任意值(函数,对象,任意基本类型),而Object的键只能是Symbel或者String 键的顺序Map中的key是有序的,因此,当迭代的时候,一个Map对象以插入的顺序返回,Object的键目前是有序的,但并不总是这样,而且这个顺序是复杂的.因此,最好不要依赖属性的顺序. 键的个数Map可以轻易获得键值对的个数,而Object只能手动计算. 迭代Map是可迭代的,而Object是不可迭代的for..of表达式无法使用 序列化和解析Map没有元素序列化和解析的支持,Object有1234567891011let test=new Map()//Map设置键值方式test.set(&#x27;a&#x27;,&#x27;263&#x27;)//Map&#123;a=&gt;263&#125;//Map获取属性值test.get(&#x27;b&#x27;)//undefined//Map是否有该属性test.has(&#x27;a&#x27;)//true//Map 清楚所有键值test.clear()//Map删除某个键值属性test.delete(&#x27;a&#x27;) 实现nodejs:events事件触发器 EventEmitter简单的实现 实现EventEmitter本质上是一个观察者模式的实现,所谓观察者模式,正常包含两个基本实现,观察者emit和被监听者on. 12345678910111213141516171819202122232425262728293031class MyEmitter &#123; constructor () &#123; this.events = new Map() &#125; on(type, fn) &#123; let handler = this.events.get(type) if (!handler) &#123; this.events.set(type, [fn]) &#125; else &#123; this.events.set(type, [...handler, fn]) &#125; &#125; emit(type, ...arg) &#123; let handler = this.events.get(type) if (handler) &#123; handler.forEach((item, i) =&gt; &#123; if (typeof item === &#x27;function&#x27;) &#123; //指定函数对目标函数进行调用 Reflect.apply(item, this, arg) &#125; else &#123; console.error(`$&#123;item&#125; is not a function in [$&#123;i&#125;]`) &#125; &#125;) &#125; &#125; &#125; let arr = new MyEmitter() arr.on(&#x27;over&#x27;, (fastName, lastName) =&gt; &#123; console.log(`大家好,我姓$&#123;fastName&#125;,名$&#123;lastName&#125;`) &#125;) arr.emit(&#x27;over&#x27;, &#x27;往&#x27;, &#x27;结&#x27;)// 大家好,我姓往,名结 箭头函数与普通函数的区别 箭头函数没有Prototype(原型),所以箭头函数本身没有this 箭头函数的this指向上下文的普通函数,当上下文没有普通函数的时候,this指向window(全局对象) 箭头函数是匿名函数,不能作为构造函数,不能使用new 箭头函数没有arguments,但可以用...解决 箭头函数不能通过call(),apply(),bind()方法来修改this指向 阻止js脚本访问cookie 给响应体设置HttpOnly,可以阻止js访问cookie,这样可以有效的防止XXS攻击,这样就保证的cookie内容的安全(XXS攻击称为跨站脚本攻击) 123response.setHeader(&#x27;Set-Cookie&#x27;,&#x27;cookiename=httponlytest,Path=/,HttpOnly&#x27;)//完毕后通过js脚本是读不到该cookie的，但使用如下方式可以读取Cookie cookies[]=request.getCookies()","categories":[],"tags":[],"author":"wjchen"},{"title":"CSS学习笔记","slug":"CSS-study","date":"2021-11-10T02:44:15.714Z","updated":"2022-05-17T03:28:07.023Z","comments":true,"path":"2021/11/10/CSS-study/","link":"","permalink":"http://example.com/2021/11/10/CSS-study/","excerpt":"","text":"css单位 分为两种绝对长度与相对长度 绝对长度 px 像素 像素是相对于屏幕分辨率的,页面按照精确像素展示,不会因其他元素的变化而变化 in 英寸 在css领域中,直接被映射成像素 1in===96px cm 厘米 映射成像素 1cm=37.8px mm 毫米 映射成像素 1mm=3.78px pt 点 (1pt = 1/72 of 1in) pc 派卡 (1pc = 12 pt) 相对长度 rem 相对于根元素的字体大小（font-size） vw 相对于视口*宽度的 1% vh 相对于视口*高度的 1% em 相对于元素的字体大小（font-size）（2em 表示当前字体大小的 2 倍） % 相对于父元素文字溢出改为省略号 单行12345.text&#123; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125; 多行12345678.all-text&#123; word-break: break-all; text-overflow: ellipsis; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; 弹性盒模型的使用 flexflexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。 flex-direction 主轴方向 row, row-reverse 行排序 正序,反序 column,column-reverse 列排序 正序,反序 flex-wrap wrap 实现多行flex容器 align-items 可以使元素在交叉轴方向对齐 stretch 弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度 flex-start 元素向侧轴起点对齐 flex-end 元素向侧轴终点对齐 center 元素在侧轴居中。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。 justify-content 元素在主轴方向上对齐 stretch flex-start元素向主轴起点对齐 flex-end元素向主轴终点对齐 center 元素在主轴居中 space-around 元素主轴分布起点,终点元素没有间隙 space-between 元素主轴分布起点,终点元素有间隙 css让文字渐变12345.text-light&#123; background-image:-webkit-linear-gradient(bottom,red,#fd8403,yellow); -webkit-background-clip:text; -webkit-text-fill-color:transparent;&#125;","categories":[],"tags":[],"author":"wjchen"},{"title":"react全家桶使用注意","slug":"react全家桶使用注意","date":"2021-09-10T02:47:40.572Z","updated":"2021-09-10T02:55:21.527Z","comments":true,"path":"2021/09/10/react全家桶使用注意/","link":"","permalink":"http://example.com/2021/09/10/react%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","excerpt":"","text":"react脚手架有两种 通过create-react-app脚手架来构建react项目(1). 通过umijs脚手架来构建react项目","categories":[],"tags":[],"author":"wjchen"},{"title":"linux学习","slug":"linux学习","date":"2021-09-03T02:55:10.090Z","updated":"2021-12-06T07:44:47.594Z","comments":true,"path":"2021/09/03/linux学习/","link":"","permalink":"http://example.com/2021/09/03/linux%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"指令 cd .. 返回上级目录 pwd 显示工作路径 ls 查看目录中的文件 ls -a 显示隐藏文件 tree 显示文件和目录由根目录开始的树形结构 mkdir my 创建名称为my的目录 rm -f file 删除一个叫file的文件 rmdir dir1 删除一个叫dir1的目录 cp file1 file2 将file1复制file2","categories":[],"tags":[],"author":"wjchen"},{"title":"vue全家桶使用注意","slug":"vue全家桶使用注意","date":"2021-08-27T07:42:35.148Z","updated":"2022-05-12T02:18:58.775Z","comments":true,"path":"2021/08/27/vue全家桶使用注意/","link":"","permalink":"http://example.com/2021/08/27/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","excerpt":"","text":"$set的使用vue是数据驱动视图更新的,但在没给数据双向绑定和data层级的非简单数据类型,就会存在视图无法更新的情况,这就用到$set来实现视图的更新. 12this.$set(target,propertyName,value)// 来实现视图的更新 组件间通讯方式 父传子父子间组件通讯是 父组件通过v-bind给子组件绑定自定义属性,传通讯信息 子组件通过props接收父组件绑定的自定义属性值1234567891011121314151617181920// 父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;children :msg=&#x27;info&#x27;&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Children from &#x27;@/components/Children.vue&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; info: &#x27;你是我的儿子&#x27; &#125; &#125;, components: &#123; Children &#125;&#125;&lt;/script&gt; 123456789101112131415161718// 子组件&lt;template&gt; &lt;div&gt; &lt;p&gt;这是父组件的信息:&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;children&#x27;, props: &#123; msg: &#123; type: String, default: &#x27;&#x27;,//默认值 require: true//是否必填 &#125; &#125;&#125;&lt;/script&gt; 子传父子组件通讯父组件是通过自定义事件来收子组件的值 子组件通过$emit(组件自定义方法,要给父组件信息)1234567891011121314151617181920212223242526// 父组件&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;这是儿子给我的信,信里写到: &#123;&#123;info&#125;&#125; &lt;/p&gt; &lt;children @info=&#x27;getLetter&#x27;&gt;&lt;/children&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Children from &#x27;@/components/Children.vue&#x27;export default &#123; name: &#x27;App&#x27;, data() &#123; return &#123; info: &#x27;&#x27; &#125; &#125;, methods: &#123; getLetter(content) &#123; this.info = content &#125; &#125;, components: &#123; Children &#125;&#125;&lt;/script&gt; 12345678910111213141516// 子组件&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;giveFather&quot;&gt;点击发送信件&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;children&#x27;, methods: &#123; giveFather() &#123; this.$emit(&#x27;info&#x27;, &#x27;父亲我想你了!&#x27;) &#125; &#125;,&#125;&lt;/script&gt; 兄弟组件通讯通过给全局创建一个new Vue()事件总线,并挂载在全局,$emit()和$on来实现兄弟组件的收发工作.12// main.jsVue.prototype.bus = new Vue() 12345678910111213141516// 组件1&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;giveBrother&quot;&gt;点击发送信件给我兄弟&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;children&#x27;, methods: &#123; giveBrother() &#123; this.bus.$emit(&#x27;getMsg&#x27;, &#x27;兄弟你真的很棒!&#x27;) &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021// 组件2&lt;template&gt; &lt;div&gt; &lt;p&gt;这是children给我的消息:&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;brother&#x27;, data() &#123; return &#123; info: &#x27;&#x27; &#125; &#125;, mounted() &#123; this.bus.$on(&#x27;getMsg&#x27;, value =&gt; &#123; this.info = value &#125;) &#125;,&#125;&lt;/script&gt; vuex 状态管理对于兄弟组件和更为复杂的组件通讯,我们可以使用vuex的状态管理,来实现全局组件的通讯,但依然会出现页面刷行后 状态管理全重置的问题,我们可以配合localStorage来将其保存,再次加载的时候,先去获取浏览器缓存的东西,做加载 vue-router的路由模式 hash模式hash模式中路由的链接带了#号 就模拟的a标签的锚点hash模式除了http请求,后端没有影响,不会重载页面 history模式history模式中路由的链接不带#号history模式会请求后端资源 前端的 URL 必须和实际向后端发起请求的 URL 一致vue的数据代理数据代理又称数据劫持,vue响应式系统的核心就是数据代理. Object.defineProperty(obj,prop,descriptor)这个方法可以精准的添加或修改对象属性,但无法对深层次的数据进行监测, proxy针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上.本质的区别是后者会创建一个新的对象对原对象做代理，外界对原对象的访问，都必须先通过这层代理进行拦截处理。而拦截的结果是我们只要通过操作新的实例对象就能间接的操作真正的目标对象了","categories":[],"tags":[],"author":"wjchen"},{"title":"element 组件使用注意","slug":"element组件使用注意","date":"2021-08-26T01:40:40.217Z","updated":"2021-12-06T07:45:23.457Z","comments":true,"path":"2021/08/26/element组件使用注意/","link":"","permalink":"http://example.com/2021/08/26/element%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/","excerpt":"","text":"表格多选分页问题需求:翻页时候,让表格多选记住上页的已选数据 首先我们需要给table组件上加上 row-key 属性绑定数据的唯一键 在多选组件上加上 reserve-selection 并绑定true 在table组件上加上 selection-change 方法 这样就实现了分页记住上页的勾选数据但这可仅仅不够,我们可能需要获取后台的数据,来实现回显 我们获取到后端数据库存的已选id,由于存在分页,所以当某页有所选id时就让其回显 先将所有的已选id存储在另一个变量中 表格行的回显,只能一行一行回显 通过table toggleRowSelection 方法来回显,这方法只能通过找到表格数据需要选中的行,将其设置成true就能将其回显 当回显过后,就将存储所有已选id的变量中删除对应元素 选择器渲染大量下拉数据问题需求:当下拉渲染大量下拉数据时会造成,页面的卡顿,我们就需要优化下拉菜单,来使页面变得流畅思路:下拉菜单仅仅只渲染50左右数据就行了,一般数据量太大,用户也很难去滑动下拉去选择,通过关键字筛选数据量,当关键字过滤的数据依旧大的时候,依然只渲染50条左右,否则全部渲染 通过elementui的select的文档,filterable是定义选择器是否可搜索,除此之外我们还需用到filter-method自定义搜索方法 通过filter-method编写自定义搜索的方法12345678910// sumlist 为字典下拉所有的数据fn(keyword)&#123; let showlist if(keyword)&#123; let filterlist=sumlist.filter(item=&gt;&#123;item.indexOf(keyword)&#125;) showlist=filterlist.length&lt;=50?filterlist:filterlist.slice(0,50) &#125;else&#123; showlist=sumlist.slice(0,50) &#125;&#125; 当然如果接口获取所有数据慢的话 建议是远程搜索的方式,直接调用接口,渲染下拉菜单 通过给select添加filterable remote 属性设置为true 通过remote-method属性绑定远程调用接口方法,来获取下拉菜单数据","categories":[],"tags":[],"author":"wjchen"},{"title":"Hello World","slug":"hello-world","date":"2021-08-21T08:17:03.203Z","updated":"2021-08-21T08:17:03.203Z","comments":true,"path":"2021/08/21/hello-world/","link":"","permalink":"http://example.com/2021/08/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}