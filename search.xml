<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node知识</title>
      <link href="/2023/03/16/node%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/16/node%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="node包管理"><a href="#node包管理" class="headerlink" title="node包管理"></a>node包管理</h5><p>  在前端高速发展中,node环境每年都有着更新,而且会导致各种依赖包的版本,需要不同的node环境来支撑,这样就会造成我们需要不同版本的node版本来支撑项目的开发,当前最热门的node包管理工具就是<code>nvm</code></p><ol><li>介绍 <code>nvm 允许你快速的切换不同的node版本</code></li><li>安装nvm<br>文件下载地址: <a href="https://github.com/coreybutler/nvm-windows/releases">nvm_window</a><br>建议选择<code>nvm-setup.exe</code>安装版的,其他版本需要额外配置环境变量<blockquote><p>notice:  </p><ul><li>安装文件放在c盘就无需进行本机的环境变量配置</li><li>若放在非c盘就需要自己配置一下环境变量 NVM_HOME 指向nvm NVM_SYMLINK 指向node</li><li>要配置淘宝镜像就需要在settings.txt 文件配置 <blockquote><ul><li><code>node_mirror: https://npm.taobao.org/mirrors/node/</code></li><li><code>npm_mirror: https://npm.taobao.org/mirrors/npm/</code></li></ul></blockquote></li><li>验证是否成功 可以查询nvm版本.</li></ul></blockquote></li><li>经常使用指令</li></ol><ul><li>安装node版本 nvm install </li><li>展开所有本地安装的node版本 nvm ls</li><li>切换使用的node版本  nvm use</li><li>获取当前使用版本  nvm current</li><li>卸载node版本 nvm unistall</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库知识</title>
      <link href="/2022/08/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/08/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>  数据库索引分为四类:稀疏索引,稠密索引,聚集索引,非聚集索引</p><ol><li>稀疏索引<br>只是一部分查找码的值有对应的索引记录</li><li>稠密索引<br><code>每个索引键值都对应一个索引项</code><br>相比稀疏索引:占用空间更小,且插入删除维护开销小</li><li>聚集索引(聚簇索引)<br>聚集索引的顺序就是数据的物理存储顺序,对表的数据按索引键的顺序进行排序,然后重新存储到磁盘上.因为数据在物理存放时只能有一种排列方式,所以一个表只能有一个聚集索引<br> 聚集索引可以重复<br><code>指针索引-&gt;物理磁盘索引,且两者索引都相同</code></li><li>非聚集索引<br>非聚集索引则与聚集索引相反,<code>两者索引不相同</code></li></ol><h5 id="ORDER-BY使用注意"><a href="#ORDER-BY使用注意" class="headerlink" title="ORDER BY使用注意"></a>ORDER BY使用注意</h5><ol><li>order by 语句用于指定的列对结果集进行排序</li><li>order by 语句默认按照升序对记录进行排序 只能作为其他子句之后的最后一个子句出现,子查询语句中是不能使用order by语句的</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网页认识</title>
      <link href="/2022/05/12/%E7%BD%91%E9%A1%B5%E8%AE%A4%E8%AF%86/"/>
      <url>/2022/05/12/%E7%BD%91%E9%A1%B5%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="页面生成过程"><a href="#页面生成过程" class="headerlink" title="页面生成过程"></a>页面生成过程</h5><ul><li><code>html文件</code>通过<code>html解析器</code>解析成 <code>DOM树</code></li><li><code>css文件</code>通过<code>css解析器</code>解析成<code>CSSOM树</code></li><li>结合DOM和CSSOM树,生成一棵渲染树</li><li>生成布局,即将所有渲染树的所有节点进行平面合成</li><li>将布局绘制在屏幕上</li></ul><h5 id="前端搭建模式-单页面模式与多页面模式"><a href="#前端搭建模式-单页面模式与多页面模式" class="headerlink" title="前端搭建模式(单页面模式与多页面模式)"></a>前端搭建模式(单页面模式与多页面模式)</h5><ul><li>多页面模式(MPA)<br>页面跳转会造成所有的html css js重新渲染 是多个完整的独立页面组成 适合用于高度追求支持搜索引擎的应用</li><li>单页面模式(SPA)<br>一个初始页面和多个页面模块组成 html css js只在初始页面的时候渲染,更换页面无需重新加载</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习笔记</title>
      <link href="/2021/11/10/HTML-study/"/>
      <url>/2021/11/10/HTML-study/</url>
      
        <content type="html"><![CDATA[<h5 id="a-标签的五种使用方法"><a href="#a-标签的五种使用方法" class="headerlink" title="a 标签的五种使用方法"></a>a 标签的五种使用方法</h5><ol><li>页面跳转(herf设置地址)<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;http://www.baidu.com&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>锚点链接(herf里面#号开头)<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;#zj&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>下载文件(herf填入资源链接地址,并设置download属性设置下载文件名)<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;http://www.baidu.com/img/bd_logo1.png&#x27;</span> <span class="attr">download</span>=<span class="string">&#x27;百度图片.png&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建email链接 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;mailto:1727482593@qq.com&#x27;</span>&gt;</span>发邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建Tel链接<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;tel:12345678&#x27;</span>&gt;</span>拨打电话<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h5>浏览器在渲染过程中,渲染引擎会触发回流和重绘</li></ol><ul><li>回流:当我们将dom元素的大小发生变化,浏览器要重新计算元素大小,这个过程称为 回流</li><li>重绘:当我们仅仅只是改变dom的颜色,此时浏览器不需要重新计算元素大小,这个过程就称为 重绘<br>在两者对比中,显然回流会比重绘更损耗性能</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS学习笔记</title>
      <link href="/2021/11/10/JS-study/"/>
      <url>/2021/11/10/JS-study/</url>
      
        <content type="html"><![CDATA[<h5 id="javascript数据类型"><a href="#javascript数据类型" class="headerlink" title="javascript数据类型"></a>javascript数据类型</h5><ol><li>基本数据类型:7种<br>String Number Boolean undefined null Symbel Bigint    - Symbel 表示独一无二的值，主要为了解决属性名冲突问题    - Bigint 是比Number类型的整数范围更大,不需要通过new来使用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当数值超过最大安全值的时候,会无法判断超出值的比较</span></span><br><span class="line"><span class="keyword">let</span> max=<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="keyword">let</span> maxOne=max+<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> maxTwo=max+<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(maxOne===maxTwo)  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> maxBig=Bigint(<span class="built_in">Number</span>.MAX_SAFE_INTEGER)</span><br><span class="line"><span class="keyword">let</span> maxBigOne=maxBig+<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> maxBigTwo=maxBig+<span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(maxBigOne===maxBigTwo) <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li>引用数据类型:1种<br>Object对象(包括普通Object、Function、Array、Date、RegExp、Math)</li></ol><h5 id="instanceof-原理的实现"><a href="#instanceof-原理的实现" class="headerlink" title="instanceof 原理的实现"></a>instanceof 原理的实现</h5><ol><li><code>instanceof</code>判断对象的原型链上是否存在构造函数的原型.仅能判断引用类型</li><li><code>instanceof</code> 判断a是否是b的实例<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断A的原型链上是否有B的原型 返回true or false</span></span><br><span class="line">A <span class="keyword">instanceof</span> B</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义实现instanceof功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">example,constructor</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span>(example)!==<span class="string">&#x27;object&#x27;</span>&amp;&amp;<span class="keyword">typeof</span>(example)!==<span class="string">&#x27;function&#x27;</span>||<span class="keyword">typeof</span>(example)===<span class="string">&#x27;null&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> exampleProto=<span class="built_in">Object</span>.getPrototypeOf(example)</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(exampleProto===<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(exampleProto===<span class="title">constructor</span>.<span class="title">prototype</span>) <span class="title">return</span> <span class="title">true</span></span><br><span class="line">    <span class="title">exampleProto</span>=<span class="title">Object</span>.<span class="title">getPrototypeOf</span>(<span class="params">exampleProto</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="cookie-localStorage-sessionStorage区别"><a href="#cookie-localStorage-sessionStorage区别" class="headerlink" title="cookie, localStorage sessionStorage区别"></a>cookie, localStorage sessionStorage区别</h5><ol><li>cookie 可以设置cookie的过期时间,默认是浏览器关闭就失效 存储大小4k左右,cookie数据始终在同源的http请求中携带,即cookie在浏览器和服务器间来回传递。cookie数据还有路径(path)的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。</li><li>localStorage 除非被清除,否则永久保存 一般为5MB</li><li>sessionStorage 仅当前会话窗口有效,关闭窗口或浏览器后被清除 一般5MB</li></ol><h5 id="Promise实现"><a href="#Promise实现" class="headerlink" title="Promise实现"></a>Promise实现</h5><p>  ES6的Promise实现需要遵循<a href="https://promisesaplus.com/">Promise/A+规范</a>,通过阅读Promise/A+规范,你可以了解到有两条核心规则</p><ol><li>Promise是一个状态控制器,且只能有三种状态:<code>pending(等待态),fulfilled(执行态),rejected(拒绝态)</code>状态是单项的,且流程不可逆</li><li><code>then()方法</code>接收两个可选参数,分别触发对应改变时触发的回调.then()方法返回一个promise,then()方法可以多次调用一个promise<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = PENDING <span class="comment">//promise 状态</span></span><br><span class="line">    <span class="built_in">this</span>._value = <span class="literal">undefined</span>  <span class="comment">// 储存then回调return的值</span></span><br><span class="line">    <span class="built_in">this</span>._resolveList = [] <span class="comment">//成功队列 resolve 触发</span></span><br><span class="line">    <span class="built_in">this</span>._rejectList = [] <span class="comment">//失败队列  reject 触发</span></span><br><span class="line">    <span class="keyword">let</span> _resolve = <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>._status !== PENDING) <span class="keyword">return</span> <span class="comment">// 对应规范中的&quot;状态只能由pending到fulfilled或rejected&quot;</span></span><br><span class="line">        <span class="built_in">this</span>._status = FULFILLED <span class="comment">//修改状态</span></span><br><span class="line">        <span class="built_in">this</span>._value = v</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>._resolveList.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> callback = <span class="built_in">this</span>._resolveList.shift()</span><br><span class="line">          callback(v)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(run)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> _reject = <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">this</span>._status = REJECTED</span><br><span class="line">        <span class="built_in">this</span>._value = v</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>._rejectList.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> callback = <span class="built_in">this</span>._rejectList.concat.shift()</span><br><span class="line">          callback(v)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(run)</span><br><span class="line">    &#125;</span><br><span class="line">    executor(_resolve, _reject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then()方法,在promise中是链式调用,且then()方法的回调拿到上个then()方法的返回值</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolveFn, rejectFn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">typeof</span> resolveFn !== <span class="string">&#x27;function&#x27;</span> ? resolveFn = <span class="function"><span class="params">v</span> =&gt;</span> v : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">typeof</span> rejectFn !== <span class="string">&#x27;function&#x27;</span> ? rejectFn = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(reason <span class="keyword">instanceof</span> <span class="built_in">Error</span> ? reason.message : reason)</span><br><span class="line">    &#125; : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fulfilledFn = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = resolveFn(v)</span><br><span class="line">          x <span class="keyword">instanceof</span> myPromise ? x.then(resolve, reject) : resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> rejectedFn = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = rejectFn(v)</span><br><span class="line">          x <span class="keyword">instanceof</span> myPromise ? x.then(resolve, reject) : reject(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (<span class="built_in">this</span>._status) &#123;</span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="comment">//将其放在对应的队列</span></span><br><span class="line">          <span class="built_in">this</span>._resolveList.push(fulfilledFn)</span><br><span class="line">          <span class="built_in">this</span>._rejectList.push(rejectedFn)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilledFn(<span class="built_in">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejectedFn(<span class="built_in">this</span>._value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// catch 方法捕获错误</span></span><br><span class="line">  <span class="keyword">catch</span>(rejectFn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, rejectFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//finally方法</span></span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">      <span class="function"><span class="params">value</span> =&gt;</span> myPromise.resolve(callback()).then(<span class="function">() =&gt;</span> value),<span class="comment">//执行回调,并returnvalue传递给后面的then</span></span><br><span class="line">      <span class="function"><span class="params">reason</span> =&gt;</span> myPromise.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)  <span class="comment">//reject同理</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态的resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> myPromise) <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态的reject方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态的all方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">        myPromise.resolve(p).then(</span><br><span class="line">          <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">            index++</span><br><span class="line">            result[i] = val</span><br><span class="line">            <span class="keyword">if</span> (index === promiseArr.length) &#123;</span><br><span class="line">              resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态的race方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseArr</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//同时执行Promise,如果有一个Promise的状态发生改变,就变更新myPromise的状态</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promiseArr) &#123;</span><br><span class="line">        myPromise.resolve(p).then(</span><br><span class="line">          <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>通过对源码的解析,catch方法其实只是调用then方法,来实现reject错误信息的捕捉,在捕捉的同时会给resolve传递undifined值,使其promise状态凝固,由拒绝态变为执行态,让其不在进行错误的捕捉</code></li></ol><h5 id="new的原理是啥-通过new的方式创建对象与字面量创建的有啥区别"><a href="#new的原理是啥-通过new的方式创建对象与字面量创建的有啥区别" class="headerlink" title="new的原理是啥?通过new的方式创建对象与字面量创建的有啥区别?"></a>new的原理是啥?通过new的方式创建对象与字面量创建的有啥区别?</h5><ol><li>new:<br> 创建一个新对象<br> 这个新对象会执行<code>[[原型]]</code>连接<br> 将构造函数的作用域赋值给新对象,即this指向新对象<br> 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line">  target.__proto__ = fn.prototype <span class="comment">//[[原型]]连接</span></span><br><span class="line">  <span class="keyword">let</span> res = fn.call(target)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (res) === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> (res) === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>字面量创建和new创建的区别<br>字面量创建对象,不会调用Object构造函数,简洁性好<br>new Object() 方式创建对象本质上是方法调用,涉及到在proto链中遍历该方法，当找到该方法后,又会生产方法调用必须的堆栈信息,方法调用结束后，还要释放该堆栈，性能不如字面量的方式。</li></ol><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>  原型链主要解决的是继承问题.<br>  每个对象拥有一个原型对象,通过proto指针指向其原型对象,并从中继承方法和属性,同时原型对象也可能拥有原型,这样一层一层,最终指向null(<code>Object.proptotype.__proto__ 指向的是null</code>)。这种关系被称为原型链,通过原型链一个对象可以拥有定义在其他对象中的属性和方法。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;cwj&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> one =  <span class="keyword">new</span> Person</span><br><span class="line"><span class="built_in">console</span>.log(one.__proto__===Person.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h5 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h5>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//当数据类型为null时直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj) <span class="comment">// 当数据为正则类型时 返回正则数据</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj) <span class="comment">//当数据为日期时,返回日期数据</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj <span class="comment">//数据不为复杂类型 直接返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当为复杂类型,就通过遍历再次递归调用</span></span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    o[key] = deepClone(obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop(事件循环)"></a>EventLoop(事件循环)</h5><p>  由于js是单线程,每步都需要执行完才能进行下一步,所以为了防止堵塞,所以会将同步代码压入同步队列,异步代码压入异步队列.异步队列又分宏任务队列与微任务队列,由于宏任务执行时间较长,而且微任务的存在目的就是为了插队,所以微任务优先与宏任务.微任务代表<code>Promise.then</code>,<code>MutationObserver</code>,宏任务代表<code>setTimeout</code>,<code>setInterval</code><br>  执行顺序总结:</p><ol><li>主线程的同步任务可以看做第一个宏任务,先执行主线程上的同步任务,异步任务放在异步队列中,宏任务放到下个宏任务队列,微任务放到微任务队列,当主线程同步任务执行完成之后,就按照先进先出的原则执行所有的微任务,微任务执行完后,执行下个宏任务队列</li><li>当宏任务执行完后,如果当前微任务队列有微任务就执行所有的微任务后,在进行下个宏任务</li><li>Promise不属于微任务,但他的.then()和.catch()才属于微任务</li></ol><h5 id="import与require的区别"><a href="#import与require的区别" class="headerlink" title="import与require的区别"></a>import与require的区别</h5><ul><li>区别1:模块加载的时间<br>require:运行时加载<br>import:编译时加载(效率更高)<code>由于是编译时加载,所以import命令会提升到文件头部</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a()</span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span></span><br></pre></td></tr></table></figure>这种情况就不会报错</li><li>区别2:模块本质区别<br>require:模块就是对象,输入时必须寻找对象属性<br>import:模块不是对象,而是通过<code>export</code>命令显式输出的代码,再通过import命令输入.由于ES6模块是在编译时加载,使得静态分析称为可能.就能进一步扩宽javascript语法,比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CommonJS模块</span></span><br><span class="line"><span class="keyword">const</span> &#123;exists,readFile&#125; =<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> exists=fs.exists</span><br><span class="line"><span class="keyword">const</span> readFile=fs.readFile</span><br></pre></td></tr></table></figure>上面实际上是加载了fs对象,fs模块所有方法实际上都加载了,在从对象上读取方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;exists,readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br></pre></td></tr></table></figure>import实际上是加载fs模块对应的两个方法,其他方法并不加载</li><li>区别3:严格模式<br>CommonJS模块与ES6模块的区别:<ol><li>CommonJS模块默认采用非严格模式 </li><li>ES6模块采用严格模式,不管你文件头部是否加入<code>use strict</code></li><li>CommonJS模块输出的是一个值的拷贝,ES6模块输出的是值的引用 (即当引入文件的参数发生变化es6引入会发生变化 而commonjs则不会变化)</li></ol></li></ul><h5 id="Map与Object的区别"><a href="#Map与Object的区别" class="headerlink" title="Map与Object的区别"></a>Map与Object的区别</h5><p>  Object与Map类似,它们都允许你按键存取一个值,删除键,检查一个键是否绑定值,不过在以下情况可能Map是最好的选择,<code>Map的快速搜索和查找数据而生的</code></p><ol><li>意外的键<br>Map创建默认不含任何键,而Object可能在原型链上存在某个属性,这样创建新键存在属性名冲突<code>我们可以用Object.create(null)来创建不含任何键的对象</code></li><li>键的类型<br>Map键的值可以是<code>任意值</code>(函数,对象,任意基本类型),而Object的键只能是<code>Symbel或者String</code></li><li>键的顺序<br>Map中的key是有序的,因此,当迭代的时候,一个Map对象以插入的顺序返回,Object的键目前是有序的,但并不总是这样,而且这个顺序是复杂的.因此,最好不要依赖属性的顺序.</li><li>键的个数<br>Map可以轻易获得键值对的个数,而Object只能手动计算.</li><li>迭代<br>Map是可迭代的,而Object是不可迭代的<code>for..of表达式无法使用</code></li><li>序列化和解析<br>Map没有元素序列化和解析的支持,Object有<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">//Map设置键值方式</span></span><br><span class="line">test.set(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;263&#x27;</span>)<span class="comment">//Map&#123;a=&gt;263&#125;</span></span><br><span class="line"><span class="comment">//Map获取属性值</span></span><br><span class="line">test.get(<span class="string">&#x27;b&#x27;</span>)<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//Map是否有该属性</span></span><br><span class="line">test.has(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//true</span></span><br><span class="line"><span class="comment">//Map 清楚所有键值</span></span><br><span class="line">test.clear()</span><br><span class="line"><span class="comment">//Map删除某个键值属性</span></span><br><span class="line">test.delete(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h5 id="实现nodejs-events事件触发器-EventEmitter简单的实现"><a href="#实现nodejs-events事件触发器-EventEmitter简单的实现" class="headerlink" title="实现nodejs:events事件触发器 EventEmitter简单的实现"></a>实现nodejs:events事件触发器 EventEmitter简单的实现</h5><p>   实现EventEmitter本质上是一个观察者模式的实现,所谓观察者模式,正常包含两个基本实现,观察者emit和被监听者on.<br>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handler = <span class="built_in">this</span>.events.get(type)</span><br><span class="line">      <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">         <span class="built_in">this</span>.events.set(type, [fn])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.events.set(type, [...handler, fn])</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type, ...arg</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> handler = <span class="built_in">this</span>.events.get(type)</span><br><span class="line">     <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">       handler.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">//指定函数对目标函数进行调用</span></span><br><span class="line">         <span class="built_in">Reflect</span>.apply(item, <span class="built_in">this</span>, arg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.error(<span class="string">`<span class="subst">$&#123;item&#125;</span> is not a function in [<span class="subst">$&#123;i&#125;</span>]`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> arr = <span class="keyword">new</span> MyEmitter()</span><br><span class="line"> arr.on(<span class="string">&#x27;over&#x27;</span>, <span class="function">(<span class="params">fastName, lastName</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`大家好,我姓<span class="subst">$&#123;fastName&#125;</span>,名<span class="subst">$&#123;lastName&#125;</span>`</span>)</span><br><span class="line"> &#125;)</span><br><span class="line"> arr.emit(<span class="string">&#x27;over&#x27;</span>, <span class="string">&#x27;往&#x27;</span>, <span class="string">&#x27;结&#x27;</span>)<span class="comment">// 大家好,我姓往,名结</span></span><br></pre></td></tr></table></figure></p><h5 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h5><ol><li>箭头函数没有Prototype(原型),所以箭头函数本身没有this</li><li>箭头函数的<code>this指向上下文的普通函数</code>,当上下文没有普通函数的时候,this指向window(全局对象)</li><li>箭头函数是<code>匿名函数</code>,不能作为<code>构造函数</code>,不能使用<code>new</code></li><li>箭头函数没有<code>arguments</code>,但可以用<code>...</code>解决</li><li>箭头函数不能通过<code>call(),apply(),bind()</code>方法来修改this指向</li></ol><h5 id="阻止js脚本访问cookie"><a href="#阻止js脚本访问cookie" class="headerlink" title="阻止js脚本访问cookie"></a>阻止js脚本访问cookie</h5><p>  给响应体设置HttpOnly,可以阻止js访问cookie,这样可以有效的防止XXS攻击,这样就保证的cookie内容的安全(XXS攻击称为跨站脚本攻击)<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&#x27;Set-Cookie&#x27;</span>,<span class="string">&#x27;cookiename=httponlytest,Path=/,HttpOnly&#x27;</span>)</span><br><span class="line"><span class="comment">//完毕后通过js脚本是读不到该cookie的，但使用如下方式可以读取</span></span><br><span class="line">Cookie cookies[]=request.getCookies()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记</title>
      <link href="/2021/11/10/CSS-study/"/>
      <url>/2021/11/10/CSS-study/</url>
      
        <content type="html"><![CDATA[<h5 id="css单位"><a href="#css单位" class="headerlink" title="css单位"></a>css单位</h5><p>  分为两种绝对长度与相对长度</p><ul><li>绝对长度<ol><li>px 像素 像素是相对于屏幕分辨率的,页面按照精确像素展示,不会因其他元素的变化而变化</li><li>in 英寸 在css领域中,直接被映射成像素 1in===96px</li><li>cm 厘米 映射成像素 1cm=37.8px</li><li>mm 毫米 映射成像素 1mm=3.78px</li><li>pt 点 (1pt = 1/72 of 1in)</li><li>pc 派卡 (1pc = 12 pt)</li></ol></li><li>相对长度<ol><li>rem 相对于根元素的字体大小（font-size）</li><li>vw 相对于视口*宽度的 1%</li><li>vh 相对于视口*高度的 1%</li><li>em 相对于元素的字体大小（font-size）（2em 表示当前字体大小的 2 倍）</li><li>% 相对于父元素<h5 id="文字溢出改为省略号"><a href="#文字溢出改为省略号" class="headerlink" title="文字溢出改为省略号"></a>文字溢出改为省略号</h5></li></ol></li></ul><ol><li>单行<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">  <span class="attribute">white-space</span>:nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>:ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>多行<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.all-text</span>&#123;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="弹性盒模型的使用-flex"><a href="#弹性盒模型的使用-flex" class="headerlink" title="弹性盒模型的使用 flex"></a>弹性盒模型的使用 flex</h5>flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。</li><li>flex-direction 主轴方向<br>   <code>row</code>, <code>row-reverse</code> 行排序 正序,反序<br>   <code>column</code>,<code>column-reverse</code> 列排序 正序,反序</li><li>flex-wrap<br>   <code>wrap</code> 实现多行flex容器</li><li>align-items 可以使元素在交叉轴方向对齐<br>   <code>stretch</code> 弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度<br>   <code>flex-start</code> 元素向侧轴起点对齐<br>   <code>flex-end</code> 元素向侧轴终点对齐<br>   <code>center</code> 元素在侧轴居中。如果元素在侧轴上的高度高于其容器，那么在两个方向上溢出距离相同。</li><li>justify-content 元素在主轴方向上对齐<br>   <code>stretch</code><br>   <code>flex-start</code>元素向主轴起点对齐<br>   <code>flex-end</code>元素向主轴终点对齐<br>   <code>center</code> 元素在主轴居中<br>   <code>space-around</code> 元素主轴分布起点,终点元素没有间隙<br>   <code>space-between</code> 元素主轴分布起点,终点元素有间隙</li></ol><h5 id="css让文字渐变"><a href="#css让文字渐变" class="headerlink" title="css让文字渐变"></a>css让文字渐变</h5><pre><code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-light</span>&#123; </span><br><span class="line">  <span class="attribute">background-image</span>:<span class="built_in">-webkit-linear-gradient</span>(bottom,red,<span class="number">#fd8403</span>,yellow);</span><br><span class="line">  -webkit-<span class="attribute">background-clip</span>:text;</span><br><span class="line">  -webkit-text-fill-<span class="attribute">color</span>:transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>react全家桶使用注意</title>
      <link href="/2021/09/10/react%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/"/>
      <url>/2021/09/10/react%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<ol><li>react脚手架有两种</li></ol><ul><li>通过create-react-app脚手架来构建react项目<br>(1). </li><li>通过umijs脚手架来构建react项目</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux学习</title>
      <link href="/2021/09/03/linux%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/03/linux%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h5><ol><li>cd .. 返回上级目录</li><li>pwd 显示工作路径</li><li>ls  查看目录中的文件</li><li>ls -a 显示隐藏文件</li><li>tree 显示文件和目录由根目录开始的树形结构</li><li>mkdir my 创建名称为my的目录</li><li>rm -f file 删除一个叫file的文件 </li><li>rmdir dir1 删除一个叫dir1的目录</li><li>cp file1 file2 将file1复制file2</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue全家桶使用注意</title>
      <link href="/2021/08/27/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/"/>
      <url>/2021/08/27/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="set的使用"><a href="#set的使用" class="headerlink" title="$set的使用"></a>$set的使用</h5><p>vue是数据驱动视图更新的,但在没给数据双向绑定和data层级的非简单数据类型,就会存在视图无法更新的情况,这就用到$set来实现视图的更新.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$set(target,propertyName,value)</span><br><span class="line"><span class="comment">// 来实现视图的更新</span></span><br></pre></td></tr></table></figure><h5 id="组件间通讯方式"><a href="#组件间通讯方式" class="headerlink" title="组件间通讯方式"></a>组件间通讯方式</h5><ol><li>父传子<br>父子间组件通讯是 父组件通过v-bind给子组件绑定自定义属性,传通讯信息 子组件通过<code>props</code>接收父组件绑定的自定义属性值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;children :msg=&#x27;info&#x27;&gt;&lt;/children&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Children from &#x27;@/components/Children.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      info: &#x27;你是我的儿子&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;这是父组件的信息:&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;children&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;,//默认值</span><br><span class="line">      require: true//是否必填</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>子传父<br>子组件通讯父组件是通过自定义事件来收子组件的值 子组件通过<code>$emit(组件自定义方法,要给父组件信息)</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;这是儿子给我的信,信里写到: &#123;&#123;info&#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;children @info=&#x27;getLetter&#x27;&gt;&lt;/children&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Children from &#x27;@/components/Children.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      info: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getLetter(content) &#123;</span><br><span class="line">      this.info = content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;giveFather&quot;&gt;点击发送信件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;children&#x27;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    giveFather() &#123;</span><br><span class="line">      this.$emit(&#x27;info&#x27;, &#x27;父亲我想你了!&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>兄弟组件通讯<br>通过给全局创建一个<code>new Vue()</code>事件总线,并挂载在全局,<code>$emit()</code>和<code>$on</code>来实现兄弟组件的收发工作.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">Vue.prototype.bus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 组件1</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;giveBrother&quot;&gt;点击发送信件给我兄弟&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;children&#x27;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    giveBrother() &#123;</span><br><span class="line">      this.bus.$emit(&#x27;getMsg&#x27;, &#x27;兄弟你真的很棒!&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 组件2</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;这是children给我的消息:&#123;&#123;info&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;brother&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      info: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.bus.$on(&#x27;getMsg&#x27;, value =&gt; &#123;</span><br><span class="line">      this.info = value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>vuex 状态管理<br>对于兄弟组件和更为复杂的组件通讯,我们可以使用<code>vuex</code>的状态管理,来实现全局组件的通讯,但依然会出现页面刷行后 状态管理全重置的问题,我们可以配合<code>localStorage</code>来将其保存,再次加载的时候,先去获取浏览器缓存的东西,做加载</li></ol><h5 id="vue-router的路由模式"><a href="#vue-router的路由模式" class="headerlink" title="vue-router的路由模式"></a>vue-router的路由模式</h5><ul><li>hash模式<br>hash模式中路由的链接带了#号 就模拟的a标签的锚点<br>hash模式除了http请求,后端没有影响,不会重载页面</li><li>history模式<br>history模式中路由的链接不带#号<br>history模式会请求后端资源 前端的 URL 必须和实际向后端发起请求的 URL 一致<h5 id="vue的数据代理"><a href="#vue的数据代理" class="headerlink" title="vue的数据代理"></a>vue的数据代理</h5>数据代理又称数据劫持,vue响应式系统的核心就是数据代理.</li><li>Object.defineProperty(obj,prop,descriptor)<br>这个方法可以精准的添加或修改对象属性,但无法对深层次的数据进行监测,</li><li>proxy<br>针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上.<br>本质的区别是后者会创建一个新的对象对原对象做代理，外界对原对象的访问，都必须先通过这层代理进行拦截处理。而拦截的结果是我们只要通过操作新的实例对象就能间接的操作真正的目标对象了</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>element 组件使用注意</title>
      <link href="/2021/08/26/element%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/"/>
      <url>/2021/08/26/element%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="表格多选分页问题"><a href="#表格多选分页问题" class="headerlink" title="表格多选分页问题"></a>表格多选分页问题</h5><p>需求:翻页时候,让表格多选记住上页的已选数据</p><ol><li>首先我们需要给table组件上加上 <code>row-key</code> 属性绑定数据的唯一键</li><li>在多选组件上加上 <code>reserve-selection</code> 并绑定true</li><li>在table组件上加上 <code>selection-change</code> 方法 这样就实现了分页记住上页的勾选数据<br>但这可仅仅不够,我们可能需要获取后台的数据,来实现回显</li><li>我们获取到后端数据库存的已选id,由于存在分页,所以当某页有所选id时就让其回显</li><li>先将所有的已选id存储在另一个变量中</li><li>表格行的回显,只能一行一行回显 通过table <code>toggleRowSelection</code> 方法来回显,这方法只能通过找到表格数据需要选中的行,将其设置成true就能将其回显</li><li>当回显过后,就将存储所有已选id的变量中删除对应元素</li></ol><h5 id="选择器渲染大量下拉数据问题"><a href="#选择器渲染大量下拉数据问题" class="headerlink" title="选择器渲染大量下拉数据问题"></a>选择器渲染大量下拉数据问题</h5><p>需求:当下拉渲染大量下拉数据时会造成,页面的卡顿,我们就需要优化下拉菜单,来使页面变得流畅<br>思路:下拉菜单仅仅只渲染50左右数据就行了,一般数据量太大,用户也很难去滑动下拉去选择,通过关键字筛选数据量,当关键字过滤的数据依旧大的时候,依然只渲染50条左右,否则全部渲染</p><ol><li>通过elementui的select的文档,<code>filterable</code>是定义选择器是否可搜索,除此之外我们还需用到<code>filter-method</code>自定义搜索方法</li><li>通过<code>filter-method</code>编写自定义搜索的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sumlist 为字典下拉所有的数据</span></span><br><span class="line"><span class="function"><span class="title">fn</span>(<span class="params">keyword</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> showlist</span><br><span class="line">  <span class="keyword">if</span>(keyword)&#123;</span><br><span class="line">    <span class="keyword">let</span> filterlist=sumlist.filter(<span class="function"><span class="params">item</span>=&gt;</span>&#123;item.indexOf(keyword)&#125;)</span><br><span class="line">    showlist=filterlist.length&lt;=<span class="number">50</span>?filterlist:filterlist.slice(<span class="number">0</span>,<span class="number">50</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    showlist=sumlist.slice(<span class="number">0</span>,<span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当然如果接口获取所有数据慢的话 建议是远程搜索的方式,直接调用接口,渲染下拉菜单</li><li>通过给select添加<code>filterable</code> <code>remote</code> 属性设置为true</li><li>通过<code>remote-method</code>属性绑定远程调用接口方法,来获取下拉菜单数据</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/08/21/hello-world/"/>
      <url>/2021/08/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
